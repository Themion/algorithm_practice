#include <cstdio>

// lst[i]: 3 * (2 * i) 크기의 벽을 채우는 경우의 수
int lst[16];

int main() {
    // 3 * N 크기의 벽을 타일로 채우는 경우를 구한다
    int n;
    scanf("%d", &n);

    // 3 * (홀수) 크기의 벽은 완벽하게 채울 수 없다
    if (n % 2 != 1) {
        // 원래대로라면 3 * 0 크기의 벽은 이미 차 있으므로 경우의 수는 1
        lst[0] = 1;
        // 3 * 2에 배치할 수 있는 경우의 수는 3
        lst[1] = 3;

        // 동적 계획법을 사용하여 문제를 해결
        // 3 * (2 * i)개를 채우는 법은 
        // 앞부분을 분할할 수 없는 방법으로 j < i인 3 * (2 * j)를 채우고
        // 나머지를 이미 계산한 3 * (2 * (i - j))칸을 채우는 경우이다
        // 이 때 j가 1일 때 분할할 수 없는 방법은 3가지이고
        // j가 2 이상이면 분할할 수 없는 방법은 2가지이므로
        // lst[i] = lst[1] * lst[i - 1] + 2(lst[0] + lst[1] + ... + lst[i - 2])
        for (int i = 2; i <= (n / 2); i++) {
            lst[i] = lst[1] * lst[i - 1];
            for (int j = 0; j < i - 1; j++) lst[i] += 2 * lst[j];
        }
    }

    printf("%d\n", lst[n / 2]);

    return 0;
}
