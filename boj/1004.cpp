#include <cstdio>

int sq(short s) { return s * s; }

int main()
{
    //ss: 각 행성계에 대해 시작점이 행성계 안에 있을 경우 true, 아니라면 false
    //ee: 각 행성계에 대해 끝점이　 행성계 안에 있을 경우 true, 아니라면 false
    bool ss, ee;

    //테스트 케이스의 수는 정해져있지 않다
    int tc;

    //s: 시작점의 좌표, e: 도착점의 좌표
    //p: 0번과 1번은 각 행성계의 중심의 좌표, 2번은 행성계의 반지름
    //cnt: 각 테스트 케이스에서 주어진 행성계의 수
    //ret: 시작점과 끝점이 같은 행성계 안에 있거나 밖에 있다면
    //      그 행성계를 굳이 지날 필요는 없다
    short s[2], e[2], p[3], cnt;

    //시작점과 끝점이 어느 행성계의 경계선에 대해 서로 반대편에 위치한다면
    //시작점과 끝점을 이었을 때 그 행성계는 반드시 지나가게 된다
    short ret;

    //테스트 케이스의 수를 입력받은 뒤
    scanf("%d", &tc);

    //각 테스트 케이스에 대해
    while (tc--)
    {
        //ret을 0으로 초기화한 뒤
        ret = 0;

        //시작점과 끝점의 좌표, 그리고 행성계의 수를 입력받는다
        scanf("%hd %hd %hd %hd", &s[0], &s[1], &e[0], &e[1]);
        scanf("%hd", &cnt);

        //각 행성계에 대해
        for (int i = 0; i < cnt; i++)
        {
            //ss와 ee를 false로 초기화한 뒤
            ss = false; ee = false;

            //행성계의 중심의 좌표와 반지름을 입력받은 뒤
            scanf("%hd %hd %hd", &p[0], &p[1], &p[2]);

            //시작점과 끝점이 행성계 안에 존재하는지 판정한다
            if (sq(s[0] - p[0]) + sq(s[1] - p[1]) < sq(p[2]))
                ss = true;
            if (sq(e[0] - p[0]) + sq(e[1] - p[1]) < sq(p[2]))
                ee = true;

            //시작점과 끝점이 행성계의 경계에 대해 서로 반대편에 위치한다면
            //ret에 1을 더해 행성계를 진입/이탈하는 횟수를 늘린다
            if (ss != ee) ret++;
        }

        //주어진 테스트 케이스에서 이상적인 경로에 대해
        //행성계의 진입/이탈 횟수를 출력한다
        printf("%d\n", ret);
    }

    return 0;
}