#include <cstdio>

int main()
{
    int N;
    scanf("%d", &N);
    /*
    가장 처음에는 상근이가 시작한다.
    상근이가 돌을 한 개 가져갈 경우 남은 돌은 N - 1개이고, 
                 세 개 가져갈 경우          N - 3개이다.
    상근이는 창영이가 돌을 한 개 가져갈 때 세 개, 
                         세 개           한 개 가져갈 수 있다.
    따라서 완벽한 플레이의 경우, 창영이가 가져간 돌과 상근이가 가져간 돌의 합은
    반드시 네 개가 된다.
    따라서 가능한 경우는 상근이가 가져갈 돌의 개수에 따라(=2가지 경우),
                       (남은 돌의 개수) % 4에 따라(=4가지 경우)
    총 8가지 경우로 축약할 수 있다.
    
    우선 상근이가 맨 처음 돌을 하나 가져간 경우, 남은 돌의 수는 0~3 개이다.
    상근이가 이미 돌을 가져갔으므로 창영이의 순서인데, 
    창영이는 돌을 하나 혹은 세 개 가져갈 수 있으니 
    남은 돌의 수가 하나 혹은 셋인 경우 창영이가 승리한다.
    이는 곧 상근이가 돌을 가져가지 않은 경우 돌이 1 + (4n + 1) = 4n + 2,
                                               1 + (4n + 3) = 4n + 4
    곧 돌이 짝수인 경우이므로 이 경우 창영이가 승리하고, 
    반대의 경우 상근이가 승리한다.
    
    다음으로 상근이가 맨 처음 돌을 셋 가져간 경우, 남은 돌의 수는 0~3 개이다.
    상근이가 이미 돌을 가져갔으므로 창영이의 순서인데, 
    창영이는 돌을 하나 혹은 세 개 가져갈 수 있으니 
    남은 돌의 수가 하나 혹은 셋인 경우 창영이가 승리한다.
    이는 곧 상근이가 돌을 가져가지 않은 경우 돌이 3 + (4n + 1) = 4n + 4,
                                               3 + (4n + 3) = 4n + 6
    곧 돌이 짝수인 경우이므로 이 경우 창영이가 승리하고, 
    반대의 경우 상근이가 승리한다.

    위 두 경우 모두 돌이 짝수인 경우 창영이가 승리하고, 또 그렇지 않은 경우 
    상근이가 승리하므로 승부의 승패는 돌의 홀짝에 따라 갈리게 된다.
    따라서 돌이 홀수인 경우 상근이가, 짝수인 경우 창영이가 승리하게 된다.
    */
    printf("%s\n", N % 2 ? "SK" : "CY");

    return 0;
}